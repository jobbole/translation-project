# Teach Yourself Computer Science #
If youâ€™re a self-taught engineer or bootcamp grad, you owe it to yourself to learn computer science. Thankfully, you can give yourself a world-class CS education without investing years and a small fortune in a degree program.

å¦‚æœä½ æ˜¯ä¸€åè‡ªå­¦å·¥ç¨‹å¸ˆæˆ–è€…æ˜¯ä¸€åè½¯ä»¶é›†è®­è¯¾ç¨‹æ¯•ä¸šçš„å­¦ç”Ÿï¼Œä½ éœ€è¦è¿™ä»½èµ„æ–™æ¥å¸®åŠ©ä½ æ›´åŠ é«˜æ•ˆçš„å­¦ä¹ è®¡ç®—æœºç§‘å­¦ã€‚å¹¸å¥½ï¼Œä½ ä¸éœ€è¦èŠ±ä¸Šå‡ å¹´çš„æ—¶é—´å’Œå­¦è´¹å»è·å¾—ç¼–ç¨‹æ–¹å‘çš„å­¦ä½å°±èƒ½è·å¾—ä¸–ç•Œé¡¶çº§çš„CSï¼ˆè®¡ç®—æœºç§‘å­¦ï¼‰è¯¾ç¨‹ã€‚

There are plenty of resources out there, but some are better than others. You donâ€™t need yet another â€œ200+ Free Online Coursesâ€ listicle. You need answers to these questions:

ç½‘ä¸Šæœ‰å¾ˆå¤šå­¦ä¹ èµ„æºï¼Œè‰¯è ä¸é½ã€‚ä½ ä¸éœ€è¦å¦å¤–çš„â€œ200+å…è´¹åœ¨çº¿è¯¾ç¨‹â€åˆ—è¡¨ã€‚ä½ éœ€è¦çš„æ˜¯å¦‚ä¸‹é—®é¢˜çš„ç­”æ¡ˆï¼š


>Which subjects should you learn, and why?
>>ä½ åº”è¯¥å­¦ä¹ å“ªé—¨è¯¾ç¨‹ï¼Ÿä¸ºä»€ä¹ˆï¼Ÿ

>What is the best book or video lecture series for each subject?
>>æ¯é—¨è¯¾ç¨‹æœ€å¥½çš„ä¹¦ç±æˆ–è€…è§†é¢‘ï¼Œè®²åº§æ˜¯ä»€ä¹ˆï¼Ÿ

This guide is our attempt to definitively answer these questions.

æˆ‘å†™è¿™ç¯‡æ–‡ç« çš„ç›®çš„å°±æ˜¯å°è¯•å¯¹äºè¿™äº›é—®é¢˜ç»™å‡ºçš„æ˜ç¡®ç­”æ¡ˆï¼š

## TL;DR: ##
Study all nine subjects below, in roughly the presented order, using either the suggested textbook or video lecture series, but ideally both. Aim for 100-200 hours of study of each topic, then revisit favorites throughout your career.

  ä½¿ç”¨å»ºè®®çš„ä¹¦ç±æˆ–è€…è§†é¢‘è®²åº§æ¥å­¦ä¹ ä»¥ä¸‹çš„ä¹é—¨ç§‘ç›®ï¼Œæœ€å¥½æ˜¯ä¹¦ç±å’Œè®²åº§éƒ½ä»”ç»†çš„ç ”ç©¶ä¸€ä¸‹ï¼Œå¯ä»¥ä¸ä¸¥æ ¼æŒ‰ç…§åˆ—å‡ºçš„é¡ºåºæ¥ã€‚æ¯ä¸€é—¨ç§‘ç›®éƒ½éœ€è¦èŠ±ä¸Š100-200å°æ—¶æ¥ç ”è¯»ï¼Œç„¶ååœ¨ä½ çš„èŒä¸šç”Ÿæ¶¯ä¸­å¯¹äºæœ€çƒ­çˆ±çš„æ–¹å‘è¿›è¡Œåå¤é‡æ¸©ã€‚


|Subject	|Why study?	|Best book	|Best videos|
|:---:|:---:|:---:|:---:|
|Programming	|Donâ€™t be the person who â€œnever quite understoodâ€ something like recursion.|Structure and Interpretation of Computer|Programs	Brian Harveyâ€™s Berkeley CS 61A|
|Computer Architecture	|If you donâ€™t have a solid mental model of how a computer actually works, all of your higher-level abstractions will be brittle.	|Computer Organization and Design|	Berkeley CS 61C|
|Algorithms and Data Structures	|If you donâ€™t know how to use ubiquitous data structures like stacks, queues, trees, and graphs, you wonâ€™t be able to solve hard problems.|The Algorithm Design Manual|	Steven Skienaâ€™s lectures|
|Math for CS|	CS is basically a runaway branch of applied math, so learning math will give you a competitive advantage.|	Mathematics for Computer Science|	Tom Leightonâ€™s MIT 6.042J|
|Operating Systems|	Most of the code you write is run by an operating system, so you should know how those interact.|	Operating Systems: Three Easy Pieces	|Berkeley CS 162|
|Computer Networking|	The Internet turned out to be a big deal: understand how it works to unlock its full potential.|	Computer Networking: A Top-Down Approach	|Stanford CS 144|
|Databases	|Data is at the heart of most significant programs, but few understand how database systems actually work.	|Readings in Database Systems|	Joe Hellersteinâ€™s Berkeley CS 186|
|Languages and Compilers	|If you understand how languages and compilers actually work, youâ€™ll write better code and learn new languages more easily.	|Compilers: Principles, Techniques and Tools|	Alex Aikenâ€™s course on Lagunita|
|Distributed Systems|	These days, most systems are distributed systems.|	Distributed Systems, 3rd Edition by Maarten van Steen|	ğŸ¤·â€|

## Why learn computer science? 
## ä¸ºä»€ä¹ˆè¦å­¦ä¹ è®¡ç®—æœºç§‘å­¦ 

There are 2 types of software engineer: those who understand computer science well enough to do challenging, innovative work, and those who just get by because theyâ€™re familiar with a few high level tools.

æœ‰ä¸¤ç§è½¯ä»¶å·¥ç¨‹å¸ˆï¼šä¸€ç§äººå¯¹äºç”µè„‘ç§‘å­¦æœ‰å¾ˆå¥½çš„ç†è§£ä»è€Œå»ä»äº‹æŒ‘æˆ˜æ€§çš„ã€å¯Œæœ‰åˆ›é€ åŠ›çš„å·¥ä½œã€‚å¦å¤–ä¸€ç§äººä»…ä»…ç†Ÿæ‚‰ä¸€äº›é«˜çº§å·¥å…·ï¼Œå¯¹å…¶åŸç†æŒå¾—è¿‡ä¸”è¿‡çš„æ€åº¦ã€‚
 
Both call themselves software engineers, and both tend to earn similar salaries in their early careers. But Type 1 engineers grow in to more fulfilling and well-remunerated work over time, whether thatâ€™s valuable commercial work or breakthrough open-source projects, technical leadership or high-quality individual contributions.

ä¸¤è€…éƒ½å«åšè½¯ä»¶å·¥ç¨‹å¸ˆï¼Œè€Œä¸”ä¸¤è€…åœ¨æ—©æœŸçš„èŒä¸šç”Ÿæ¶¯ä¸­å¯èƒ½é¢†ç€åŒæ ·çš„è–ªæ°´ã€‚ä½†æ˜¯ç¬¬ä¸€ç§å·¥ç¨‹å¸ˆï¼Œä¸ç®¡ä»–ä»äº‹çš„æ˜¯å•†ä¸šå·¥ä½œï¼Œè¿˜æ˜¯çªç ´æ€§çš„å¼€æºå·¥ç¨‹ï¼Œéƒ½ä¼šç”±äºä»–çš„æŠ€æœ¯é¢†å¯¼åŠ›æˆ–è€…æ°å‡ºçš„ä¸ªäººè´¡çŒ®ä¸€ç‚¹ä¸€ç‚¹æˆé•¿æˆä¸€åå¯¹äºç¼–ç¨‹æ›´åŠ ç—´è¿·è€Œä¸”å¾…é‡æ›´é«˜çš„å·¥ç¨‹å¸ˆã€‚

Type 1 engineers find ways to learn computer science in depth, whether through conventional means or by relentlessly learning throughout their careers. Type 2 engineers typically stay at the surface, learning specific tools and technologies rather than their underlying foundations, only picking up new skills when the winds of technical fashion change.
 
ç¬¬ä¸€ç§å·¥ç¨‹å¸ˆå¯ä»¥é€šè¿‡å¸¸è§„æ‰‹æ®µæˆ–è€…åœ¨èŒä¸šç”Ÿæ¶¯ä¸­ä¸æ–­å­¦ä¹ æ¥åŠ æ·±å¯¹äºè®¡ç®—æœºç§‘å­¦çš„ç†è§£æ·±åº¦ã€‚ç¬¬äºŒç§å·¥ç¨‹å¸ˆé€šå¸¸åœç•™åœ¨è¡¨é¢ï¼Œå­¦ä¹ å…·ä½“çš„å·¥å…·æˆ–è€…æŠ€å·§è€Œä¸æ˜¯å…¶ä¸­çš„åŸºç¡€ï¼Œå½“å‰æµè¡Œä»€ä¹ˆæŠ€æœ¯ï¼Œä»–ä»¬å°±ä»…ä»…æ¡èµ·æ–°çš„æŠ€èƒ½å­¦ä¹ ä¸€ä¸‹ã€‚

Currently, the number of people entering the industry is rapidly increasing, while the number of CS grads is essentially static. This oversupply of Type 2 engineers is starting to reduce their employment opportunities and keep them out of the industryâ€™s more fulfilling work. Whether youâ€™re striving to become a Type 1 engineer or simply looking for more job security, learning computer science is the only reliable path.

è¿‘äº›å¹´æ¥ï¼Œè¶Šæ¥è¶Šå¤šçš„äººè¿›å…¥è½¯ä»¶é¢†åŸŸå·¥ä½œï¼Œä½†æ˜¯æœ¬è´¨ä¸Šè®¡ç®—æœºç§‘å­¦çš„æ¯•ä¸šç”Ÿæ•°é‡æ˜¯æ²¡æœ‰æ”¹å˜çš„ã€‚ç¬¬äºŒç§å·¥ç¨‹å¸ˆçš„ä¾›åº”è¿‡é‡å¼€å§‹å¯¼è‡´ä»–ä»¬çš„å°±ä¸šæœºä¼šå˜å°‘è€Œä¸”å¯¼è‡´ä»–ä»¬ç¦»ä¼ä¸šä¸­ä»¤äººæ„Ÿè§‰å……å®çš„å·¥ä½œæ›´è¿œã€‚ä¸ç®¡ä½ æ˜¯åŠªåŠ›è¦æˆä¸ºç¬¬ä¸€ç§å·¥ç¨‹å¸ˆæˆ–è€…ä»…ä»…æ˜¯ä¿é™©èµ·è§åœ°æƒ³æ‰¾åˆ°æ›´å¤šçš„å·¥ä½œï¼Œå­¦ä¹ è®¡ç®—æœºç§‘å­¦æ˜¯å”¯ä¸€ä¸€ç§å¯é çš„é€”å¾„ã€‚

## Subject guides ##
## è¯¾ç¨‹æŒ‡å—

### Programming ###
### ç¼–ç¨‹

Most undergraduate CS programs start with an â€œintroductionâ€ to computer programming. The best versions of these courses cater not just to novices, but also to those who missed beneficial concepts and programming models while first learning to code.

å¤§å¤šæ•°å¤§å­¦çš„è®¡ç®—æœºç¼–ç¨‹è¯¾ç¨‹é€šå¸¸ä»¥â€œå…¥é—¨ç±»â€è®¡ç®—æœºçš„è¯¾ç¨‹å¼€å§‹ã€‚è¿™äº›è¯¾ç¨‹æœ€å¥½æ˜¯ä¸ä»…ä»…é’ˆå¯¹äºåˆå­¦è€…ï¼Œè€Œä¸”å¯¹äºç¬¬ä¸€æ¬¡å­¦ä¹ ç¼–ç¨‹ï¼ŒåŸºæœ¬æ¦‚å¿µå’Œç¼–ç¨‹æ¨¡å‹ä¸æ˜¯å¾ˆç†Ÿæ‚‰çš„äººä¹Ÿæœ‰æ‰€å¯å‘çš„ã€‚

Our standard recommendation for this content is the classicÂ Structure and Interpretation of Computer Programs, which is available online for free both asÂ a book, and as a set ofÂ MIT video lectures. While those lectures are great, our video suggestion is actuallyÂ Brian Harveyâ€™s SICP lecturesÂ (for the 61A course at Berkeley) instead. These are more refined and better targeted at new students than are the MIT lectures.

å¯¹äºè¿™ç§ä»‹ç»çš„å†…å®¹çš„æˆ‘ä»¬ç»™å‡ºçš„æ ‡å‡†å»ºè®®æ˜¯ç»å…¸çš„è®¡ç®—æœºç¨‹åºçš„ç»“æ„ä¸è§£é‡Šï¼Œåœ¨ç½‘ç»œä¸Šèƒ½æ‰¾åˆ°å¾ˆå¤šè¿™æ ·çš„èµ„æ–™ï¼Œå®ƒä»¬å¯èƒ½æ˜¯[ç”µå­ä¹¦](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/book.html)æˆ–è€…æ˜¯MITçš„ä¸€ç³»åˆ—è®²åº§[è§†é¢‘](http://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-001-structure-and-interpretation-of-computer-programs-spring-2005/video-lectures/)ã€‚è¿™äº›è®²åº§éƒ½å¾ˆä¸é”™ï¼Œä½†æ˜¯æˆ‘ä»¬çš„è§†é¢‘æ¨èçš„å®é™…ä¸Šæ˜¯ä¼¯å…‹åˆ©çš„ä¸€é—¨è¯¾ç¨‹ï¼š[Brian Harveyâ€™s SICP lectures](https://archive.org/details/ucberkeley-webcast-PL3E89002AA9B9879E?sort=titleSorter) ï¼Œè¿™ä¸ªç³»åˆ—çš„è¯¾ç¨‹æ¯”èµ·MITçš„è®²åº§æ›´ç²¾ç‚¼è€Œä¸”å¯¹äºå…¥é—¨è€…æ›´å…·æœ‰é’ˆå¯¹æ€§ã€‚

We recommend working through at least the first three chapters of SICP and doing the exercises. For additional practice, work through a set of small programming problems like those onÂ exercism.

æˆ‘ä»¬æ¨èè§‚çœ‹å®Œè‡³å°‘å‰ä¸‰ç« èŠ‚çš„SICPï¼ˆè®¡ç®—æœºç¨‹åºçš„ç»“æ„ä¸è§£é‡Šï¼‰å¹¶ä¸”åšå®Œç›¸åº”è®­ç»ƒã€‚é¢å¤–åœ°ï¼Œå¯ä»¥åœ¨ exercism è¿›è¡Œä¸€äº›ç¼–ç¨‹é—®é¢˜è®­ç»ƒã€‚

![image](https://teachyourselfcs.com/sicp.jpg)

For those who find SICP too challenging, we recommendÂ How to Design Programs. For those who find it too easy, we recommendÂ Concepts, Techniques, and Models of Computer Programming.
 
å¦‚æœä½ è§‰å¾—SICPå¤ªéš¾ï¼Œæˆ‘ä»¬æ¨è*[How to Design Programs](http://www.htdp.org/)*.è¿™æœ¬ä¹¦ã€‚å¦‚æœä½ è§‰å¾—å®ƒå¤ªç®€å•ï¼Œæˆ‘ä»¬æ¨è*[Concepts, Techniques, and Models of Computer Programming](https://smile.amazon.com/Concepts-Techniques-Models-Computer-Programming/dp/0262220695/)* è¿™æœ¬ä¹¦ã€‚

### Computer Architecture 
### è®¡ç®—æœºä½“ç³»ç»“æ„

>Hardware is the platform

â€“ Mike Acton, Engine Director at Insomniac Games
([æ”¶çœ‹ä»–åœ¨Cppå¤§ä¼šä¸Šçš„æ¼”è®²](https://www.youtube.com/watch?v=rX0ItVEVjHc))


Computer Architectureâ€”sometimes called â€œcomputer systemsâ€ or â€œcomputer organizationâ€â€”is an important first look at computing below the surface of software. In our experience, itâ€™s the most neglected area among self-taught software engineers.

è®¡ç®—æœºç»“æ„--æœ‰çš„æ—¶å€™è¢«ç§°ä¸ºâ€œè®¡ç®—æœºç³»ç»Ÿâ€æˆ–è€…â€œè®¡ç®—æœºç»„ç»‡â€--æ˜¯äº†è§£ç¨‹åºå¤–è¡¨ä¸‹è®¡ç®—æœºè¿è¡Œçš„ç¬¬ä¸€æ­¥ã€‚æ ¹æ®æˆ‘ä»¬çš„ç»éªŒï¼Œè¿™æ˜¯è‡ªå­¦è½¯ä»¶å·¥ç¨‹å¸ˆæœ€å®¹æ˜“å¿½ç•¥çš„åœ°æ–¹ã€‚

The Elements of Computing Systems, also known as â€œNand2Tetrisâ€ is an ambitious book attempting to give you a cohesive understanding of how everything in a computer works. Each chapter involves building a small piece of the overall system, from writing elementary logic gates in HDL, through a CPU and assembler, all the way to an application the size of a Tetris game.
 
*The Elements of Computing Systems*ï¼Œä¹Ÿè¢«ç§°ä¸ºâ€œä»ä¸éé—¨åˆ°ä¿„ç½—æ–¯æ–¹å—â€ã€‚è¿™æ˜¯ä¸€æœ¬è®©ä½ å¯¹äºè®¡ç®—æœºä¸­çš„æ¯ä¸€ä¸ªé›¶ä»¶æ˜¯æ€ä¹ˆå·¥ä½œçš„æœ‰ä¸€ä¸ªæ•´ä½“çš„ç†è§£çš„é›„å¿ƒå‹ƒå‹ƒçš„ä¹¦ã€‚æ¯ä¸ªç« èŠ‚æ¶‰åŠåˆ°å»ºç«‹æ•´ä½“ç³»ç»Ÿä¸­ä¸€ä¸ªå°çš„éƒ¨åˆ†ï¼Œä»å†™åŸºæœ¬çš„é€»è¾‘é—¨åˆ°HDLï¼Œåˆ°CPUå’Œæ±‡ç¼–è¯­è¨€ï¼Œä¸€ç›´åˆ°å®Œæˆä¸€ä¸ªä¿„ç½—æ–¯æ–¹å—åº”ç”¨ç¨‹åºã€‚

![elements-computing-systems](https://teachyourselfcs.com/elements-computing-systems.jpg)

We recommend reading through the first six chapters of the book and completing the associated projects. This will develop your understanding of the relationship between the architecture of the machine and the software that runs on it.
 
æˆ‘ä»¬æ¨èé˜…è¯»ä¹¦çš„å‰å…­ç« èŠ‚å¹¶ä¸”å®Œæˆç›¸å…³çš„å·¥ç¨‹ã€‚è¿™ä¼šæé«˜ä½ å¯¹äºè®¡ç®—æœºç»“æ„å’Œè¿è¡Œçš„è½¯ä»¶ä¹‹é—´å…³ç³»çš„ç†è§£ã€‚

The first half of the book (and all of its projects), are available for free fromÂ the Nand2Tetris website. Itâ€™s also available asÂ a Coursera course with accompanying videos.

è¿™æœ¬ä¹¦çš„å‰åŠéƒ¨åˆ†ï¼ˆå’Œå®ƒçš„å…¨éƒ¨å·¥ç¨‹ï¼‰åœ¨[the Nand2Tetris website](http://www.nand2tetris.org/)ä¸Šå¯ä»¥å…è´¹è·å¾—ã€‚åœ¨[Coursera course with accompanying videos](https://www.coursera.org/learn/build-a-computer)ä¸Šä½ ä¹Ÿå¯ä»¥æ‰¾åˆ°å®ƒä»¬ã€‚

In seeking simplicity and cohesiveness, Nand2Tetris trades off depth. In particular, two very important concepts in modern computer architectures are pipelining and memory hierarchy, but both are mostly absent from the text.
 
ä¸ºäº†ä¿è¯è¯¾ç¨‹ç®€å•å¹¶å¸å¼•äººï¼ŒNand2Tetris èˆå¼ƒäº†æ·±åº¦ã€‚ç‰¹åˆ«æ˜¯ç°ä»£è®¡ç®—æœºç»“æ„ä¸­ä¸¤ä¸ªå¾ˆé‡è¦çš„æ¦‚å¿µï¼šæµæ°´çº¿(pipelining)å’Œå†…å­˜å±‚çº§(memory hierarchy)ï¼Œåœ¨ä¹¦ä¸­éƒ½æ²¡æœ‰æåŠã€‚

Once you feel comfortable with the content of Nand2Tetris, our next suggestion is Patterson and Hennessyâ€™sÂ Computer Organization and Design, an excellent and now classic text. Not every section in the book is essential; we suggest following Berkeleyâ€™sÂ CS61C courseâ€œGreat Ideas in Computer Architectureâ€ for specific readings. The lecture notes and labs are available online, and past lectures areÂ on the Internet Archive.
 
å½“ä½ è§‰å¾—çœ‹Nand2Tetriså·²ç»å¾ˆç®€å•äº†ï¼Œæˆ‘ä»¬ä¸‹ä¸€ä¸ªå»ºè®®æ˜¯Pattersonå’ŒHennessyåˆè‘—çš„*Computer Organization and Design*â€”â€”ä¸€æœ¬æ°å‡ºçš„ç°ä»£ç»å…¸ä¹¦ç±ã€‚ä¸æ˜¯ä¹¦ä¸­æ‰€æœ‰çš„éƒ¨åˆ†éƒ½å¾ˆé‡è¦ï¼›æˆ‘ä»¬å»ºè®®è·Ÿéš[Berkeleyâ€™s CS61C è¯¾ç¨‹](http://inst.eecs.berkeley.edu/~cs61c/sp15/)â€”â€”Great Ideas in Computer Architectureï¼Œä½œä¸ºç‰¹æ®Šè¯»ç‰©ã€‚è®²åº§çš„ç¬”è®°å’Œå®éªŒç¯å¢ƒéƒ½æ˜¯åœ¨çº¿çš„ï¼Œè€Œä¸”å¯ä»¥åœ¨[åœ¨è¿™ä¸ªå½’æ¡£é“¾æ¥](https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iCl2-D-FS5mk0jFF6cYSJs_)å›çœ‹è®²åº§ã€‚

### Algorithms and Data Structures ###
### ç®—æ³•å’Œæ•°æ®ç»“æ„

>I have only one method that I recommend extensivelyâ€”itâ€™s called think before you write.

>â€” Richard Hamming

We agree with decades of common wisdom that familiarity with common algorithms and data structures is one of the most empowering aspects of a computer science education. This is also a great place to train oneâ€™s general problem-solving abilities, which will pay off in every other area of study.

æˆ‘ä»¬æ ¹æ®å‡ åå¹´çš„é€šè¯†æ¥çœ‹ï¼Œç†Ÿæ‚‰é€šç”¨çš„ç®—æ³•å’Œæ•°æ®ç»“æ„æ˜¯è®¡ç®—æœºç§‘å­¦æ•™è‚²ä¸­æœ€é‡è¦çš„æ–¹é¢ä¹‹ä¸€ã€‚è¿™æ˜¯ä¸€ä¸ªè®­ç»ƒä¸€ä¸ªäººè§£å†³é—®é¢˜çš„é€šç”¨èƒ½åŠ›çš„æ–¹å¼ï¼Œè€Œä¸”è¿™ç§èƒ½åŠ›è¿˜å¯ä»¥è¿ç§»åˆ°å…¶ä»–é¢†åŸŸçš„å­¦ä¹ ã€‚

There are hundreds of books available, but our favorite isÂ The Algorithm Design ManualÂ by Steven Skiena. He clearly loves this stuff and canâ€™t wait to help you understand it. This is a refreshing change, in our opinion, from the more commonly recommended Cormen, Leiserson, Rivest & Stein, or Sedgewick books. These last two texts tend to be too proof-heavy for those learning the material primarily to help themÂ solve problems.

è¿™ä¸ªé¢†åŸŸæœ‰å¾ˆå¤šä¼˜ç§€çš„ä¹¦ç±ï¼Œä½†æ˜¯æˆ‘ä»¬æœ€å–œæ¬¢çš„æ˜¯Steven Skienaçš„*The Algorithm Design Manual* ã€‚ä»–æ˜¾ç„¶å–œæ¬¢è¿™ä¸œè¥¿è€Œä¸”ä¹Ÿè¿«ä¸åŠå¾…åœ°æƒ³å¸®åŠ©ä½ å­¦ä¹ æ•°æ®ç»“æ„å’Œç®—æ³•ã€‚è¿™æ˜¯ä»¤äººè€³ç›®ä¸€æ–°çš„å˜åŒ–ï¼Œæˆ‘ä»¬è®¤ä¸ºè¿™æœ¬ä¹¦ç›¸å¯¹äºè¢«æ›´å¤šäººæ‰€æ¨èçš„Cormen, Leiserson, Rivest & Stein æˆ–è€… Sedgewick çš„ä¹¦æ¥è¯´æ›´å¥½ã€‚åä¸¤æœ¬ä¹¦æœ‰äº›å¤ªè¿‡äºå¼•ç»æ®å…¸ï¼Œå¯¹äºæƒ³é€šè¿‡é˜…è¯»æ¥è§£å†³é—®é¢˜çš„äººæ¥è¯´å¹¶ä¸æ˜¯ä¸€ä¸ªå¥½çš„é€‰æ‹©ã€‚

![skiena](https://teachyourselfcs.com/skiena.jpg)


For those who prefer video lectures,Â Skiena generously provides his online. We also really like Tim Roughgardenâ€™s course, available from Stanfordâ€™s MOOC platform Lagunita, orÂ on Coursera. Whether you prefer Skienaâ€™s or Roughgardenâ€™s lecture style will be a matter of personal preference.

å¯¹äºé‚£äº›æ›´å–œæ¬¢è®²åº§è§†é¢‘çš„äººæ¥è¯´ï¼Œæˆ‘ä»¬æ¨èSkienaçš„[è®²åº§](http://www3.cs.stonybrook.edu/~algorith/video-lectures/). æˆ‘ä»¬ä¹Ÿå–œæ¬¢Tim Roughgardençš„è¯¾ç¨‹ï¼Œåœ¨æ–¯å¦ç¦çš„MOOCå¹³å°æˆ–è€…[Coursera](https://www.coursera.org/specializations/algorithms)ä¸Šé¢å¯ä»¥è·å¾—ã€‚ä½ å–œæ¬¢ Skiena è¿˜æ˜¯ Roughgarden çš„è®²è¯¾é£æ ¼å°±æ˜¯ä½ çš„ä¸ªäººå–œå¥½é—®é¢˜äº†ã€‚

For practice, our preferred approach is for students to solve problems onÂ Leetcode. These tend to be interesting problems with decent accompanying solutions and discussions. They also help you test progress against questions that are commonly used in technical interviews at the more competitive software companies. We suggest solving around 100 random leetcode problems as part of your studies.

è¯´åˆ°ç»ƒä¹ ï¼Œæˆ‘ä»¬å€¾å‘äºè®©å­¦ç”Ÿåœ¨Leetcodeä¸Šé¢è§£å†³é—®é¢˜ã€‚LeetCodeä¸Šé¢çš„é—®é¢˜éƒ½æ¯”è¾ƒæœ‰è¶£è€Œä¸”æœ‰ç­”æ¡ˆå’Œè®¨è®ºã€‚è¿™ä¸Šé¢è¿˜å¯ä»¥é€šè¿‡è§£å†³å„å¤§è½¯ä»¶å…¬å¸å¹¿æ³›åº”ç”¨çš„æŠ€æœ¯é—®é¢˜æ¥å¸®åŠ©ä½ æµ‹è¯•ä½ çš„è¿›æ­¥ã€‚æˆ‘ä»¬å»ºè®®è§£å†³ä½ å­¦ä¹ çš„æ—¶å€™è§£å†³å¤§çº¦éšæœº100é“LeetCodeä¸Šé¢çš„é—®é¢˜ã€‚

Finally, we strongly recommendÂ How to Solve ItÂ as an excellent and unique guide to general problem solving; itâ€™s as applicable to computer science as it is to mathematics.

æœ€åï¼Œæˆ‘ä»¬å¼ºçƒˆæ¨èã€Šæ€æ ·è§£é¢˜ã€‹è¿™æœ¬ä¹¦ï¼Œå®ƒé’ˆå¯¹å¦‚ä½•è§£é¢˜è¿›è¡Œäº†ç²¾å½©ç»ä¼¦å’Œç‹¬ç‰¹çš„è®²è§£ï¼Œæ—¢é€‚ç”¨äºæ•°å­¦ä¹Ÿé€‚ç”¨äºç”µè„‘ç§‘å­¦ã€‚

![polya](https://teachyourselfcs.com/polya.jpg)

### Mathematics for Computer Science ###
### è®¡ç®—æœºç§‘å­¦é¢†åŸŸçš„æ•°å­¦

>If people do not believe that mathematics is simple, it is only because they do not realize how complicated life is.

>â€” John von Neumann

In some ways, computer science is an overgrown branch of applied mathematics. While many software engineers tryâ€”and to varying degrees succeedâ€”at ignoring this, we encourage you to embrace it with direct study. Doing so successfully will give you an enormous competitive advantage over those who donâ€™t.

åœ¨æŸäº›æ–¹é¢ï¼Œè®¡ç®—æœºç§‘å­¦æ˜¯åº”ç”¨æ•°å­¦çš„ä¸€ä¸ªæ‰©å±•ã€‚è™½ç„¶è®¸å¤šè½¯ä»¶å·¥ç¨‹å¸ˆå¿½ç•¥äº†è¿™ä¸€ç‚¹ï¼Œæˆ‘ä»¬å»ºè®®ä½ å»å­¦ä¹ å®ƒã€‚å¥½å¥½å­¦ä¹ æ•°å­¦ä¼šç»™ä½ æ¯”é‚£äº›ä¸å­¦ä¹ å®ƒä»¬çš„äººå·¨å¤§çš„ç«äº‰ä¼˜åŠ¿ã€‚

The most relevant area of math for CS is broadly called â€œdiscrete mathematicsâ€, where â€œdiscreteâ€ is the opposite of â€œcontinuousâ€ and is loosely a collection of interesting applied math topics outside of calculus. Given the vague definition, itâ€™s not meaningful to try to cover the entire breadth of â€œdiscrete mathematicsâ€. A more realistic goal is to build a working understanding of logic, combinatorics and probability, set theory, graph theory, and a little of the number theory informing cryptography. Linear algebra is an additional worthwhile area of study, given its importance in computer graphics and machine learning.

å’ŒCSæœ€ç›¸å…³çš„æ•°å­¦é¢†åŸŸæ˜¯â€œç¦»æ•£æ•°å­¦â€ï¼Œç¦»æ•£æ˜¯è¿ç»­å¯¹ç«‹é¢ã€‚æ˜¯å¾®ç§¯åˆ†ä¹‹å¤–çš„ä¸€ç³»åˆ—çš„æœ‰è¶£çš„åº”ç”¨æ•°å­¦çš„ä¸»é¢˜ã€‚ä»å¤§ä½“ä¸Šè¯´ï¼Œå°è¯•å­¦ä¼šå…¨éƒ¨èŒƒå›´çš„â€œç¦»æ•£æ•°å­¦â€æ˜¯æ²¡æœ‰æ„ä¹‰çš„ã€‚æ›´ç°å®ä¸€ç‚¹çš„åšæ³•æ˜¯å¯¹äºé€»è¾‘å­¦ï¼Œç»„åˆå­¦å’Œæ¦‚ç‡å­¦ï¼Œé›†åˆè®ºï¼Œå›¾è®ºå’Œä¸€äº›æ•°è®ºå‘ŠçŸ¥å¯†ç å­¦æœ‰ä¸€ä¸ªäº†è§£ã€‚å¯¹äºè®¡ç®—æœºå›¾åƒå­¦å’Œæœºå™¨å­¦ä¹ æ¥è¯´ï¼Œçº¿æ€§ä»£æ•°ä¹Ÿæ˜¯ä¸€é—¨å€¼å¾—å­¦ä¹ çš„è¯¾ç¨‹ã€‚

Our suggested starting point for discrete mathematics is the set ofÂ lecture notes by LÃ¡szlÃ³ LovÃ¡sz. Professor LovÃ¡sz did a good job of making the content approachable and intuitive, so this serves as a better starting point than more formal texts.

æˆ‘ä»¬å»ºè®®ä»LÃ¡szlÃ³ LovÃ¡szçš„[è®²åº§](http://www.cs.elte.hu/~lovasz/dmbook.ps)å­¦èµ·. è¿™ä¸€ç³»åˆ—å¼€å§‹å­¦ä¹ ç¦»æ•£æ•°å­¦ã€‚LovÃ¡sz æ•™æˆè®©å­¦ä¹ çš„å†…å®¹å˜å¾—ç›´è§‚ç”ŸåŠ¨ï¼Œæ¯”èµ·æ‹˜è°¨çš„æ–‡å­—ï¼Œè¿™æ›´åˆ©äºä½ å­¦ä¹ ã€‚

For a more advanced treatment, we suggestÂ Mathematics for Computer Science, the book-length lecture notes for the MIT course of the same name. That courseâ€™s video lectures are alsoÂ freely available, and are our recommended video lectures for discrete math.

æ¥ä¸‹æ¥ï¼Œæˆ‘ä»¬æ¨è[Mathematics for Computer Science](https://courses.csail.mit.edu/6.042/spring17/mcs.pdf), å®ƒæ˜¯MITåŒåè¯¾ç¨‹çš„è®²ä¹‰ã€‚[è®²åº§è¯¾ç¨‹](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-fall-2010/video-lectures/)çš„è§†é¢‘ä¹Ÿæ˜¯å…è´¹çš„ï¼Œè€Œä¸”æ˜¯æˆ‘ä»¬æ¨èçš„ç¦»æ•£æ•°å­¦çš„è§†é¢‘è¯¾ç¨‹ã€‚

For linear algebra, we suggest starting with theÂ Essence of linear algebraÂ video series, followed by Gilbert Strangâ€™sÂ bookÂ andÂ video lectures.

çº¿æ€§ä»£æ•°ï¼Œæˆ‘ä»¬å»ºè®®ä» [Essence of linear algebra](https://www.youtube.com/playlist?list=PLZHQObOWTQDPD3MizzM2xVFitgF8hE_ab) ç³»åˆ—å¼€å§‹å­¦ä¹ ï¼Œæ¥ç€æ˜¯Gilbert Strangçš„[ä¹¦ç±](https://www.amazon.com/Introduction-Linear-Algebra-Gilbert-Strang/dp/0980232775/)å’Œ[è§†é¢‘](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/video-lectures/)ã€‚

### Operating Systems ###
### æ“ä½œç³»ç»Ÿ

Operating System Concepts (the â€œDinosaur bookâ€) and Modern Operating Systems are the â€œclassicâ€ books on operating systems. Both have attracted criticism for their writing styles, and for being the 1000-page-long type of textbook that gets bits bolted onto it every few years to encourage purchasing of the â€œlatest editionâ€.

ã€Šæ“ä½œç³»ç»Ÿçš„æ¦‚å¿µã€‹ï¼ˆæé¾™ä¹¦ï¼‰å’Œã€Šç°ä»£æ“ä½œç³»ç»Ÿã€‹æ˜¯ç»å…¸çš„æ“ä½œç³»ç»Ÿçš„ä¹¦ç±ã€‚è¿™ä¸¤æœ¬ä¹¦çš„å†™ä½œæ–¹å¼éƒ½é¥±å—äº‰è®®ï¼Œè€Œä¸”ä¸ºäº†é¼“åŠ±ä½ å»è´­ä¹°æ–°ç‰ˆï¼Œè¿™äº›é•¿è¾¾1000é¡µçš„ä¹¦æ¯å‡ å¹´å°±ä¼šæ·»åŠ ä¸€äº›å†…å®¹ã€‚

Operating Systems: Three Easy PiecesÂ is a good alternative thatâ€™sÂ freely available online. We particularly like the structure of the book and feel that the exercises are well worth doing.

ã€ŠOperating Systems: Three Easy Piecesã€‹è¿™æœ¬ä¹¦æ˜¯ä¸€æœ¬æ¯”è¾ƒå¥½çš„å¯ä¾›é€‰æ‹©çš„çº¿ä¸Šå…è´¹è¯»ç‰©ã€‚æˆ‘ä»¬ç‰¹åˆ«å–œæ¬¢ä¹¦çš„ç»“æ„å’Œå®ƒç»å…¸çš„ç»ƒä¹ é¢˜ã€‚

![ostep](https://teachyourselfcs.com/ostep.jpeg)


After OSTEP, we encourage you to explore the design decisions of specific operating systems, through â€œ{OS name} Internalsâ€ style books such asÂ Lion's commentary on Unix,Â The Design and Implementation of the FreeBSD Operating System, andÂ Mac OS X Internals.

è¯»å®Œè¿™æœ¬ä¹¦ï¼Œæˆ‘ä»¬æ¨èä½ å»æ¢ç´¢ä¸€ç§ç‰¹å®šçš„æ“ä½œç³»ç»Ÿçš„è®¾è®¡æ–¹å¼ï¼Œæ¯”å¦‚é‚£äº›ä¹¦åä¸­æœ‰ç³»ç»Ÿåå­—çš„ä¹¦ç±ï¼Œæ¯”å¦‚Lionâ€˜s commentary on Unix, The Design and Implementation of the FreeBSD Operating System, è¿˜æœ‰ Mac OS X Internals.

A great way to consolidate your understanding of operating systems is to read the code of a small kernel and add features. A great choice isÂ xv6, a port of Unix V6 to ANSI C and x86 maintained for a course at MIT. OSTEP has an appendix of potentialÂ xv6 labsÂ full of great ideas for potential projects.

å·©å›ºä½ å¯¹äºæ“ä½œç³»ç»Ÿçš„ç†è§£å¾ˆå¥½çš„æ–¹å¼æ˜¯å»è¯»ä¸€ä¸ªå°çš„å†…æ ¸å¹¶ä¸”æ·»åŠ åŠŸèƒ½ã€‚xv6æ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ï¼Œå®ƒæ˜¯ Unix V6 å’Œ ANSI C å’Œ X86 çš„æ¥å£ï¼ŒMITä¸“é—¨æœ‰ä¸€é—¨è¯¾ç¨‹å°±æ˜¯è®²è¿™ä¸ªçš„ã€‚OSTEPï¼ˆä¹‹å‰æåˆ°çš„ï¼‰è¿™æœ¬ä¹¦æœ‰ä¸€ä¸ª XV6 çš„å®éªŒé™„å½•ï¼Œé‡Œé¢éƒ½æ˜¯å……æ»¡æ½œåŠ›é¡¹ç›®çš„å¥½ç‚¹å­ã€‚

### Computer Networking ###
### è®¡ç®—æœºç½‘ç»œ

>You canâ€™t gaze in the crystal ball and see the future. What the Internet is going to be in the future is what society makes it.

>â€” Bob Kahn

Given that so much of software engineering is on web servers and clients, one of the most immediately valuable areas of computer science is computer networking. Our self-taught students who methodically study networking find that they finally understand terms, concepts and protocols theyâ€™d been surrounded by for years.

è€ƒè™‘åˆ°å¾ˆå¤šè½¯ä»¶é¡¹ç›®éƒ½æ˜¯åŸºäºwebæœåŠ¡å™¨å’Œå®¢æˆ·ç«¯çš„ï¼Œè®¡ç®—æœºç½‘ç»œå˜æˆè®¡ç®—æœºç§‘å­¦ä¸­ä¸€é—¨æœ‰å®ç”¨ä»·å€¼çš„å­¦ç§‘ã€‚ç³»ç»Ÿå­¦ä¹ è¿‡è¯¥è¯¾ç¨‹çš„è‡ªå­¦å­¦ç”Ÿå‘ç°ä»–ä»¬ç»ˆäºç†è§£äº†å›´ç»•äº†ä¼´éšå®ƒä»¬å¾ˆå¤šå¹´çš„æœ¯è¯­ï¼Œæ¦‚å¿µï¼Œåè®®ç­‰ç­‰ã€‚

Our favorite book on the topic isÂ Computer Networking: A Top-Down Approach. The small projects and exercises in the book are well worth doing, and we particularly like the â€œWireshark labsâ€, which they haveÂ generously provided online.

å…³äºè¿™ä¸ªä¸»é¢˜æˆ‘ä»¬æœ€æ¨èçš„ä¹¦æ˜¯ï¼šã€Šè®¡ç®—æœºç½‘ç»œâ€”â€”è‡ªé¡¶å‘ä¸‹æ–¹æ³•ã€‹ã€‚ä¹¦ä¸­çš„å°å·¥ç¨‹å’Œå®éªŒéƒ½å¾ˆå¥½ï¼Œå€¼å¾—ä¸€åšã€‚æˆ‘ä»¬éå¸¸å–œæ¬¢å®ƒä»¬æä¾›çš„[Wireshark labs](http://www-net.cs.umass.edu/wireshark-labs/)ã€‚

![](https://teachyourselfcs.com/top-down.jpg)

For those who prefer video lectures, we suggest Stanfordâ€™sÂ Introduction to Computer Networking courseÂ available on their MOOC platform Lagunita.

å¯¹äºé‚£äº›å–œæ¬¢è§†é¢‘è¯¾ç¨‹çš„äººï¼Œæˆ‘ä»¬æ¨èæ–¯å¦ç¦MOOCå¹³å°ä¸Šçš„[Introduction to Computer Networking course](https://lagunita.stanford.edu/courses/Engineering/Networking-SP/SelfPaced/about)

The study of networking benefits more from projects than it does from small exercises. Some possible projects are: an HTTP server, a UDP-based chat app, aÂ mini TCP stack, a proxy or load balancer, and a distributed hash table.

å­¦ä¹ ç½‘ç»œçš„å¥½å¤„ä¸ä»…ä»…åœ¨äºåšå°çš„å®éªŒè€Œä¸”å¯¹äºå·¥ç¨‹æ¥è¯´ä¹Ÿæœ‰å¾ˆå¤§çš„å¥½å¤„ã€‚å¯èƒ½æ¶‰åŠåˆ°çš„æœ‰ï¼šä¸€ä¸ªHTTPçš„æœåŠ¡å™¨ï¼Œä¸€ä¸ªUDPåè®®çš„èŠå¤©è½¯ä»¶ï¼Œä¸€ä¸ª[è¿·ä½ çš„TCPåè®®æ ˆ](http://jvns.ca/blog/2014/08/12/what-happens-if-you-write-a-tcp-stack-in-python/)ï¼Œä¸€ä¸ªä»£ç†æˆ–è€…è´Ÿè½½å¹³è¡¡å™¨ï¼Œè¿˜æœ‰åˆ†å¸ƒå¼çš„å“ˆå¸Œè¡¨ç­‰ç­‰ã€‚

### Databases ###
### æ•°æ®åº“

It takes more work to self-learn about database systems than it does with most other topics. Itâ€™s a relatively new (i.e. post 1970s) field of study with strong commercial incentives for ideas to stay behind closed doors. Additionally, many potentially excellent textbook authors have preferred to join or start companies instead.

å¯¹äºè‡ªå­¦è€…æ¥è¯´ï¼Œå­¦ä¹ æ•°æ®åº“ç³»ç»Ÿä¼šæ¯”å­¦ä¹ å…¶ä»–èŠ±è´¹æ›´å¤šçš„æ—¶é—´ã€‚è¿™æ˜¯ä¸€ä¸ªç›¸å¯¹è¾ƒæ–°çš„ï¼ˆå³1970å¹´ä»£åæœŸï¼‰çš„ç ”ç©¶é¢†åŸŸã€‚æ¯”èµ·å†™ä¹¦ï¼Œè®¸å¤šæ½œåœ¨çš„æ°å‡ºæ•™ç§‘ä¹¦ä½œè€…æ›´æ„¿æ„å»åŠ å…¥æˆ–è€…åˆ›åŠä¸€å®¶å…¬å¸ã€‚

Given the circumstances, we encourage self-learners to generally avoid textbooks and start with theÂ Spring 2015 recording of CS 186, Joe Hellersteinâ€™s databases course at Berkeley, and to progress to reading papers after.

åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å»ºè®®è‡ªå­¦è€…æ”¾å¼ƒæ•™ç§‘ä¹¦è€Œå»å­¦ä¹ ä¼¯å…‹åˆ©çš„Joe Hellersteinçš„[æ•°æ®åº“è¯¾ç¨‹](https://archive.org/details/UCBerkeley_Course_Computer_Science_186)ï¼Œçœ‹å®Œè¯¾ç¨‹å†å»é˜…è¯»è®ºæ–‡ã€‚

One paper particularly worth mentioning for new students is â€œArchitecture of a Database Systemâ€, which uniquely provides a high-level view of how relational database management systems (RDBMS) work. This will serve as a useful skeleton for further study.

å¯¹äºåˆå­¦è€…æœ‰ä¸€ç¯‡è®ºæ–‡æ¯”è¾ƒæ¨èçš„æ˜¯ï¼šâ€œ[Architecture of a Database System](http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf)â€,å®ƒé«˜å±‹å»ºç“´åœ°è®²è§£äº†å…³ç³»æ•°æ®åº“ç®¡ç†ç³»ç»Ÿæ˜¯å¦‚æœå·¥ä½œçš„è¿™ä¸€é—®é¢˜ã€‚å®ƒä¼šä¸ºä½ æœªæ¥çš„å­¦ä¹ æä¾›ä¸€ä¸ªæœ‰ç”¨çš„çº²è¦ã€‚

Readings in Database Systems, better known asÂ the databases â€œRed Bookâ€, is a collection of papers compiled and edited by Peter Bailis, Joe Hellerstein and Michael Stonebraker. For those who have progressed beyond the level of the CS 186 content, the Red Book should be your next stop.

*[Readings in Database Systems](http://www.redbook.io/)*è¿™æœ¬ä¹¦ï¼Œåˆè¢«ç§°ä¸ºæ•°æ®åº“çº¢çš®ä¹¦ã€æ˜¯ä¸€æœ¬Peter Bailisã€Joe Hellersteinå’ŒMichael Stonebrakerç¼–è¾‘åœ°è®ºæ–‡é›†ã€‚å¯¹äºé‚£äº›ç†è§£äº†CS 186å†…å®¹çš„äººæ¥è¯´ï¼Œçº¢çš®ä¹¦æ˜¯ä½ çš„ä¸äºŒä¹‹é€‰ã€‚

![](https://teachyourselfcs.com/redbook.jpg)


If you insist on using an introductory textbook, we suggestÂ Database Management Systemsby Ramakrishnan and Gehrke. For more advanced students, Jim Grayâ€™s classicÂ Transaction Processing: Concepts and TechniquesÂ is worthwhile, but we donâ€™t encourage using this as a first resource.

å¦‚æœä½ åšæŒè¦ä½¿ç”¨ä¸€æœ¬å¼•å¯¼æ€§çš„æ•™ç§‘ä¹¦ï¼Œæˆ‘ä»¬æ¨èRamakrishnan å’ŒGehrkeçš„[*Database Management Systems*](https://smile.amazon.com/Database-Management-Systems-Raghu-Ramakrishnan/dp/0072465638/)ï¼Œå¯¹äºæ›´ä¼˜ç§€çš„å­¦ç”Ÿï¼ŒJim Grayçš„ä¼ ç»Ÿè¯¾ç¨‹[*Transaction Processing: Concepts and Techniques*](https://www.amazon.com/Transaction-Processing-Concepts-Techniques-Management/dp/1558601902)å€¼å¾—ä¸€çœ‹ï¼Œä½†æ˜¯æˆ‘ä»¬ä¸å»ºè®®æŠŠå®ƒå½“æˆå…¥é—¨ä¹¦ã€‚

Itâ€™s hard to consolidate databases theory without writing a good amount of code. CS 186 students add features to Spark, which is a reasonable project, but we suggest just writing a simple relational database management system from scratch. It will not be feature rich, of course, but even writing the most rudimentary version of every aspect of a typical RDBMS will be illuminating.

ä¸ç¼–å¤§é‡çš„ä»£ç æ˜¯ä¸èƒ½å¾ˆå¥½çš„å·©å›ºæ•°æ®åº“çš„ç†è®ºçš„ï¼ŒCS 186çš„å­¦ç”Ÿå¾€Sparkä¸­æ·»åŠ åŠŸèƒ½ï¼Œè¿™æ˜¯ä¸€ä¸ªå¾ˆæœ‰æ„ä¹‰çš„å·¥ç¨‹ã€‚ä½†æ˜¯æˆ‘ä»¬å»ºè®®ä»…ä»…æ˜¯ä»å¤´å†™ä¸€ä¸ªç®€å•çš„å…³ç³»æ•°æ®åº“ç®¡ç†ç³»ç»Ÿã€‚åŠŸèƒ½å¯èƒ½ä¸æ˜¯å¾ˆä¸°å¯Œï¼Œä½†æ˜¯å³ä½¿æ¯ä¸€ä¸ªéƒ¨åˆ†éƒ½æ¶‰åŠåˆ°ä¸€äº›åŸºæœ¬åŠŸèƒ½ä¹Ÿå¾ˆæœ‰å¯å‘æ€§ã€‚

Finally, data modeling is a neglected and poorly taught aspect of working with databases. Our suggested book on the topic isÂ Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World.

æœ€åï¼Œæ•°æ®æ¨¡å‹æ˜¯ä¸€ä¸ªæ•°æ®åº“ä½¿ç”¨ä¸­è¢«å¿½ç•¥å’Œæ²¡æœ‰è¢«é‡ç‚¹å­¦ä¹ çš„æ–¹é¢ã€‚æˆ‘ä»¬å¯¹äºè¿™ä¸ªè¯¾é¢˜å»ºè®®çš„ä¹¦ç±æ˜¯ï¼š[*Data and Reality: A Timeless Perspective on Perceiving and Managing Information in Our Imprecise World*](https://www.amazon.com/Data-Reality-Perspective-Perceiving-Information/dp/1935504215)

![](https://teachyourselfcs.com/data-reality.jpg)

### Languages and Compilers ###
### è¯­è¨€å’Œç¼–è¯‘å™¨

>Donâ€™t be a boilerplate programmer. Instead, build tools for users and other programmers. Take historical note of textile and steel industries: do you want to build machines and tools, or do you want to operate those machines?

>â€” Ras Bodik at the start of his compilers course


Most programmers learn languages, whereas most computer scientists learn about languages. This gives the computer scientist a distinct advantage over the programmer, even in the domain of programming! Their knowledge generalizes; they are able to understand the operation of a new language more deeply and quickly than those who have merely learned specific languages.

å¤§éƒ¨åˆ†ç¨‹åºå‘˜å­¦ä¹ å¦‚ä½•ä½¿ç”¨ä¸€é—¨ç¼–ç¨‹è¯­è¨€ï¼Œç„¶è€Œå¤§éƒ¨åˆ†çš„è®¡ç®—æœºç§‘å­¦å®¶åˆ™å­¦ä¹ è¿™é—¨è¯­è¨€æœ¬èº«ã€‚è¿™ç»™äº†è®¡ç®—æœºç§‘å­¦å®¶æ¯”èµ·ç¨‹åºå‘˜å¾ˆæ˜æ˜¾çš„ä¼˜åŠ¿ã€‚ä»–ä»¬çš„çŸ¥è¯†èƒ½å¤Ÿæ›´å¥½çš„æ³›åŒ–ï¼Œä»–ä»¬èƒ½æ¯”ç®€ç®€å•å•åœ°æŒæ¡ä¸€é—¨è¯­è¨€çš„æ›´åŠ æ·±å…¥å’Œå¿«é€Ÿçš„ç†è§£ä¸€é—¨æ–°è¯­è¨€çš„æ“ä½œã€‚

The canonical introductory text isÂ Compilers: Principles, Techniques & Tools, commonly called â€œthe Dragon Bookâ€. Unfortunately, itâ€™s not designed for self-study, but rather for instructors to pick out 1-2 semesters worth of topics for their courses. Itâ€™s almost essential then, that you cherry-pick the topics, ideally with the help of a mentor.

ç»å…¸çš„æ•™ç§‘ä¹¦ã€Šç¼–è¯‘å™¨ï¼šåŸç†ã€æŠ€æœ¯ä¸å·¥å…·ã€‹é€šå¸¸åˆè¢«ç§°ä¸ºâ€œé¾™ä¹¦â€ã€‚ä¸å¹¸çš„æ˜¯ï¼Œè¿™æœ¬ä¹¦å¹¶ä¸é€‚åˆè‡ªå­¦è€…ï¼Œå®ƒæ¯”è¾ƒé€‚åˆæ•™å¸ˆä»ä¸­é€‰å‡º1-2ä¸ªç« èŠ‚å¹¶åœ¨è¯¾å ‚ä¸Šè®²æˆã€‚è¿™æœ¬ä¹¦æ˜¯æœ‰å¿…è¦çœ‹çš„ï¼Œä½ å¯ä»¥æŒ‘é€‰é‡Œé¢çš„ä¸»é¢˜ï¼Œæœ€å¥½å†æœ‰ä¸ªå¸ˆå‚…æŒ‡å¯¼ä½ ã€‚

![](https://teachyourselfcs.com/dragon.jpg)

If you choose to use the Dragon Book for self-study, we recommend following a video lecture series for structure, then dipping into the Dragon Book as needed for more depth. Our recommended online course isÂ Alex Aikenâ€™s, available from Stanfordâ€™s MOOC platform Lagunita.

å¦‚æœä½ é€‰æ‹©åœ¨è‡ªå­¦ä¸­ä½¿ç”¨é¾™ä¹¦ï¼Œæˆ‘ä»¬æ¨èä½ ä¸€ç³»åˆ—é—¨è§†é¢‘è®²åº§ï¼Œç„¶åå†æ²‰æµ¸åœ¨å¯¹äºé¾™ä¹¦çš„ç ”ç©¶ä¸­ã€‚æˆ‘ä»¬æ¨èçš„åœ¨çº¿è¯¾ç¨‹æ˜¯ï¼šAlex Aiken çš„[è®²åº§](https://lagunita.stanford.edu/courses/Engineering/Compilers/Fall2014/about)ï¼Œä½ å¯ä»¥åœ¨æ–¯å¦ç¦å¤§å­¦çš„å¹•è¯¾å¹³å°ä¸Šè§‚çœ‹ã€‚

As a potential alternative to the Dragon Book we suggestÂ Language Implementation PatternsÂ by Terence Parr. It is written more directly for the practicing software engineer who intends to work on small language projects like DSLs, which may make it more practical for your purposes. Of course, it sacrifices some valuable theory to do so.
 
ä¹Ÿæœ‰å¯ä»¥æ›¿ä»£é¾™ä¹¦çš„æ•™æï¼šTerence Parrå†™çš„[*Language Implementation Patterns*](https://smile.amazon.com/Language-Implementation-Patterns-Domain-Specific-Programming/dp/193435645X/)ï¼Œå®ƒæ›´é€‚åˆé‚£äº›å·¥ä½œä¸­ä½¿ç”¨ç±»ä¼¼ç‰¹å®šé¢†åŸŸè¯­è¨€çš„å°ä¼—è¯­è¨€çš„æœ‰ç»éªŒçš„ç¼–ç¨‹è€…ï¼Œå®ƒæ˜¾å¾—æ›´åŠ å®ç”¨ã€‚å½“ç„¶ï¼Œä¸ºäº†è¾¾åˆ°è¿™ä¸ªç›®çš„å®ƒä¹Ÿåˆ å»äº†ä¸€äº›æœ‰ä»·å€¼çš„ç†è®ºã€‚

![](https://teachyourselfcs.com/parr.jpg)

For project work, we suggest writing a compiler either for a simple teaching language like COOL, or for a subset of a language that interests you. Those who find such a project daunting could start withÂ Make a Lisp, which steps you through the project.

å¯¹äºå·¥ç¨‹å®è·µï¼Œæˆ‘ä»¬æ¨èä½ å†™ä¸€ä¸ªç¼–è¯‘å™¨ï¼Œä½ å¯ä»¥é€‰æ‹©åƒCOOLè¿™ç§ç®€å•çš„æ•™å­¦è¯­è¨€æˆ–è€…ä½ æ„Ÿå…´è¶£çš„ä¸€é—¨è¯­è¨€ã€‚å¦‚æœä½ è§‰å¾—å¤ªéš¾ï¼Œä½ å¯ä»¥å‚è€ƒ[Make a Lisp](https://github.com/kanaka/mal),ä½ å¯ä»¥å‚è€ƒå®ƒä½œä¸ºå¼€å§‹ã€‚

### Distributed Systems ###
### åˆ†å¸ƒå¼ç³»ç»Ÿ

As computers have increased in number, they have also spread. Whereas businesses would previously purchase larger and larger mainframes, itâ€™s typical now for even very small applications to run across multiple machines. Distributed systems is the study of how to reason about the trade-offs involved in doing so, an increasingly important skill.

è®¡ç®—æœºçš„æ•°é‡å¢é•¿äº†ï¼Œå®ƒä»¬çš„åˆ†å¸ƒä¹Ÿæ›´å¹¿äº†ã€‚ä¼ä¸šä¹‹å‰ä¼šè´­ä¹°è¶Šæ¥è¶Šå¤§å‹çš„ä¸»æœºï¼Œä½†æ˜¯ç°åœ¨å¤§å®¶æ›´å€¾å‘äºåœ¨å¾ˆå¤šæœºå™¨ä¸Šåˆ†å¸ƒå¼çš„è¿è¡Œå¤šä¸ªå°å‹çš„åº”ç”¨ç¨‹åºã€‚åˆ†å¸ƒå¼ç³»ç»Ÿç ”ç©¶çš„å°±æ˜¯è¿™æ ·çš„æŠ€æœ¯ï¼Œè¿™ä¸€æŠ€æœ¯å˜å¾—è¶Šæ¥è¶Šé‡è¦äº†ã€‚
  
Our suggested textbook for self-study is Maarten van Steen and Andrew Tanenbaumâ€™sÂ Distributed Systems, 3rd Edition. Itâ€™s a great improvement over the previous edition, and is available for free online thanks to the generosity of its authors. Given that the distributed systems is a rapidly changing field, no textbook will serve as a trail guide, but Maarten van Steenâ€™s is the best overview weâ€™ve seen of well-established foundations.

æˆ‘ä»¬å»ºè®®çš„è‡ªå­¦æ•™ç§‘ä¹¦æ˜¯Maarten van Steenå’ŒAndrew Tanenbaumçš„[*Distributed Systems, 3rd Edition*](https://www.distributed-systems.net/index.php/books/distributed-systems-3rd-edition-2017/) é’ˆå¯¹äºä¹‹å‰çš„ç‰ˆæœ¬åšäº†å¾ˆå¤§çš„æ”¹è¿›ï¼Œè€Œä¸”ä½œè€…æ…·æ…¨åœ°æŠŠä¹¦æ”¾åœ¨äº†ç½‘ä¸Šå…±äº«ã€‚ç”±äºåˆ†å¸ƒå¼è®¡ç®—æ˜¯ä¸€é—¨å˜åŒ–å¾ˆå¿«çš„é¢†åŸŸï¼Œæ‰€ä»¥æ²¡æœ‰æ•™ç§‘ä¹¦å¯ä»¥å¾ˆå¥½çš„æ¶µç›–æ‰€æœ‰çš„å†…å®¹ã€‚ä½†æ˜¯Maarten van Steençš„ä¹¦æ˜¯æˆ‘ä»¬è¯»è¿‡çš„æ‰€æœ‰ä¹¦ä¸­æœ€å¥½çš„ä¹¦ã€‚

![](https://teachyourselfcs.com/distsys.png)

A good course for which some videos are online isÂ MITâ€™s 6.824Â (a graduate course), but unfortunately the audio quality in the recordings is poor, and itâ€™s not clear if the recordings were authorized.

ç ”ç©¶ç”Ÿåœ¨çº¿è¯¾ç¨‹[MITâ€™s 6.824](https://www.youtube.com/watch?v=hBWfjkGKRas&list=PLkcQbKbegkMqiWf7nF8apfMRL4P4sw8UL) ä¹Ÿæ˜¯ä¸€ä¸ªä¸é”™çš„é€‰æ‹©ï¼Œä½†å¯æƒœè§†é¢‘ä¸­çš„éŸ³è´¨ä¸å¤ªå¥½ï¼Œè€Œä¸”ä¸æ¸…æ¥šè¿™äº›è§†é¢‘æ˜¯ä¸æ˜¯éƒ½è¢«æˆæƒè¿‡ã€‚

No matter the choice of textbook or other secondary resources, study of distributed systems absolutely mandates reading papers. A good list isÂ here, and we would highly encourage attending your localÂ Papers We LoveÂ chapter.

å°½ç®¡æœ‰å‚è€ƒä¹¦æˆ–è€…å…¶å®ƒçš„èµ„æºï¼Œä½†å­¦ä¹ åˆ†å¸ƒå¼ç³»ç»Ÿæ˜¯ç»å¯¹è¦è¯»è®ºæ–‡çš„ã€‚é“¾æ¥ä¸­æœ‰ä¸€ä¸ªå¾ˆå¥½çš„[æ¸…å•](http://dsrg.pdos.csail.mit.edu/papers/)ï¼Œè€Œä¸”æˆ‘ä»¬ååˆ†æ¨èä½ ä»[Papers We Love](http://paperswelove.org/)Â ä¸Šé¢ä¸‹è½½è®ºæ–‡åˆ°æœ¬åœ°å­¦ä¹ ã€‚
  
## Frequently asked questions
## å¸¸è§é—®é¢˜

